import logging
import random
from typing import Dict, List, Optional, Any
import discord
from redbot.core import commands, Config
from redbot.core.bot import Red

from aiuser.messages_list.messages import MessagesList, create_messages_list
from aiuser.response.chat.llm_pipeline import LLMPipeline
from aiuser.response.chat.response import remove_patterns_from_response
from aiuser.types.abc import MixinMeta
from aiuser.utils.endpoint_manager import EndpointManager
from aiuser.utils.response_rating import ResponseRating

logger = logging.getLogger("red.bz_cogs.aiuser")

class RegenerationView(discord.ui.View):
    """Discord UI View for response regeneration"""
    
    def __init__(self, cog: MixinMeta, ctx: commands.Context, original_message: discord.Message, 
                 messages_list: MessagesList, timeout: float = 1800):
        super().__init__(timeout=timeout)
        self.cog = cog
        self.ctx = ctx
        self.original_message = original_message
        self.messages_list = messages_list
        self.endpoint_manager = EndpointManager(cog.bot, cog.config)
        self.rating_system = ResponseRating(cog.config)
        
        # Add regeneration dropdown
        self.add_item(RegenerationDropdown(self))
        
        # Add rating buttons
        self.add_item(ThumbsUpButton(self))
        self.add_item(ThumbsDownButton(self))
    
    async def on_timeout(self):
        """Called when the view times out"""
        for item in self.children:
            item.disabled = True
        try:
            await self.original_message.edit(view=self)
        except discord.NotFound:
            pass
    
    async def regenerate_with_model(self, model_config: Dict[str, Any], interaction: discord.Interaction):
        """Regenerate response with specified model"""
        await interaction.response.defer()
        
        try:
            # Get the appropriate client for this endpoint
            client = await self.endpoint_manager.get_client(model_config["endpoint"])
            if not client:
                await interaction.followup.send("❌ Failed to connect to endpoint", ephemeral=True)
                return
            
            # Create a temporary pipeline with the new model
            temp_messages = MessagesList(
                self.messages_list.ctx,
                self.messages_list.author,
                self.messages_list.channel_id,
                self.messages_list.guild_id,
                model_config["model"],
                self.messages_list.can_reply,
                self.messages_list.messages,
                self.messages_list.conversation_mode
            )
            
            # Set the client for this endpoint
            original_client = self.cog.openai_client
            self.cog.openai_client = client
            
            try:
                pipeline = LLMPipeline(self.cog, self.ctx, temp_messages)
                await pipeline.setup_tools()
                response = await pipeline.generate_response()
                
                if response:
                    # Clean the response
                    cleaned_response = await remove_patterns_from_response(self.ctx, self.cog.config, response)
                    
                    # Update the original message
                    embed = discord.Embed(
                        description=cleaned_response,
                        color=discord.Color.blue()
                    )
                    embed.set_footer(text=f"Generated by {model_config['name']} via {model_config['endpoint']}")
                    
                    await self.original_message.edit(content=None, embed=embed, view=self)
                    await interaction.followup.send(f"✅ Regenerated with {model_config['name']}", ephemeral=True)
                else:
                    await interaction.followup.send("❌ Failed to generate response", ephemeral=True)
                    
            finally:
                # Restore original client
                self.cog.openai_client = original_client
                
        except Exception as e:
            logger.error(f"Failed to regenerate response: {e}")
            await interaction.followup.send("❌ An error occurred during regeneration", ephemeral=True)

class RegenerationDropdown(discord.ui.Select):
    """Dropdown for selecting regeneration model"""
    
    def __init__(self, parent_view: RegenerationView):
        self.parent_view = parent_view
        super().__init__(
            placeholder="Choose a model to regenerate...",
            min_values=1,
            max_values=1
        )
    
    async def callback(self, interaction: discord.Interaction):
        """Handle model selection"""
        # Allow any user to regenerate responses (not just original requester)
        # This makes sense for @mentions and random responses where anyone should be able to try different models
        
        selected_model = self.values[0]
        regen_models = await self.parent_view.cog.config.regen_models()
        
        model_config = None
        for model in regen_models:
            if f"{model['name']}:{model['endpoint']}" == selected_model:
                model_config = model
                break
        
        if model_config:
            await self.parent_view.regenerate_with_model(model_config, interaction)
        else:
            await interaction.response.send_message("❌ Model configuration not found", ephemeral=True)
    
    async def setup_options(self):
        """Setup dropdown options based on available models"""
        try:
            available_models = await self.parent_view.endpoint_manager.get_available_models()
            
            self.options = []
            for model in available_models:
                emoji = "⭐" if model.get("default", False) else "🤖"
                self.options.append(discord.SelectOption(
                    label=model["name"],
                    value=f"{model['name']}:{model['endpoint']}",
                    description=f"Via {model['endpoint']}",
                    emoji=emoji
                ))
            
            if not self.options:
                self.options = [discord.SelectOption(
                    label="No models available",
                    value="none",
                    description="Configure regeneration models first"
                )]
                self.disabled = True
                
        except Exception as e:
            logger.error(f"Failed to setup regeneration options: {e}")
            self.options = [discord.SelectOption(
                label="Error loading models",
                value="error",
                description="Check configuration"
            )]
            self.disabled = True

class ThumbsUpButton(discord.ui.Button):
    """Thumbs up rating button"""
    
    def __init__(self, parent_view: RegenerationView):
        self.parent_view = parent_view
        super().__init__(style=discord.ButtonStyle.green, emoji="👍")
    
    async def callback(self, interaction: discord.Interaction):
        """Handle thumbs up"""
        await self._handle_rating(interaction, "thumbs_up")

    async def _handle_rating(self, interaction: discord.Interaction, rating: str):
        """Handle rating submission"""
        try:
            # Get current model info from embed footer
            embed = self.parent_view.original_message.embeds[0] if self.parent_view.original_message.embeds else None
            model_info = "Unknown"
            endpoint_info = "Unknown"
            
            if embed and embed.footer:
                footer_text = embed.footer.text
                if "Generated by" in footer_text:
                    parts = footer_text.replace("Generated by ", "").split(" via ")
                    if len(parts) == 2:
                        model_info = parts[0]
                        endpoint_info = parts[1]
            
            # Create unique rating key (message_id + user_id) to allow multiple users to rate the same response
            rating_key = f"{self.parent_view.original_message.id}_{interaction.user.id}"
            
            # Log the rating
            await self.parent_view.rating_system.log_rating(
                message_id=rating_key,  # Use composite key for unique user ratings
                user_id=interaction.user.id,
                guild_id=interaction.guild.id,
                model=model_info,
                endpoint=endpoint_info,
                rating=rating,
                response_content=embed.description if embed else None
            )
            
            emoji = "👍" if rating == "thumbs_up" else "👎"
            await interaction.response.send_message(f"{emoji} Rating recorded! Thank you for the feedback.", ephemeral=True)
            
        except Exception as e:
            logger.error(f"Failed to record rating: {e}")
            await interaction.response.send_message("❌ Failed to record rating", ephemeral=True)

class ThumbsDownButton(discord.ui.Button):
    """Thumbs down rating button"""
    
    def __init__(self, parent_view: RegenerationView):
        self.parent_view = parent_view
        super().__init__(style=discord.ButtonStyle.red, emoji="👎")
    
    async def callback(self, interaction: discord.Interaction):
        """Handle thumbs down"""
        await ThumbsUpButton._handle_rating(self, interaction, "thumbs_down")

async def add_regeneration_view(cog: MixinMeta, ctx: commands.Context, 
                               message: discord.Message, messages_list: MessagesList) -> discord.Message:
    """Add regeneration view to a message"""
    try:
        view = RegenerationView(cog, ctx, message, messages_list)
        
        # Setup dropdown options
        if hasattr(view.children[0], 'setup_options'):
            await view.children[0].setup_options()
        
        # Edit message to include the view
        await message.edit(view=view)
        return message
        
    except Exception as e:
        logger.error(f"Failed to add regeneration view: {e}")
        return message

async def get_random_model(cog: MixinMeta) -> Optional[Dict[str, Any]]:
    """Get a random model from available regeneration models"""
    try:
        endpoint_manager = EndpointManager(cog.bot, cog.config)
        available_models = await endpoint_manager.get_available_models()
        
        if available_models:
            return random.choice(available_models)
        return None
        
    except Exception as e:
        logger.error(f"Failed to get random model: {e}")
        return None